---
tags:
  - diary
  - 卒業研究
---
> [!IMPORTANT]
> 雑な思いつきを書いていこう
> 終わったらChatGPTに突っ込んだりして企画書整形しようね

グラフ追加します（オブシの検索性）

第2段階の仕様（LLMも検討しよう）、
来週は研究とその仕様を説明（おおまかに）

# 📘 構造可視化仕様書（暫定版）

---

## 🧭 概要

本システムは、ユーザーが段階的に入力するSQLクエリに基づいて、データベースのスキーマ構造を可視化するツールである。  
構造可視化は2段階に分けて実行される：

- **第1段階**：クエリの構文とカラム名から確定情報を抽出・描画

---

## 🔹 第1段階：クエリベースの構造可視化

### 入力：

- SQLクエリ（SELECT / JOIN / GROUP BY など）

### 処理フロー：

1. `sql_parser.py`
    - クエリからテーブル・カラム・JOIN条件を抽出
2. `nlp_analyzer.py`
    - カラム名から意味カテゴリ（例：id, name, time, price）を推定
3. `schema_store.py`
    - 構造情報を蓄積・差分記録・スナップショット保存
4. `visualizer.py`
    - 構造を NetworkX + matplotlib で描画

### 表示仕様：

|要素|表現|
|---|---|
|テーブルノード|大きな円（黒縁、白塗り）|
|カラムノード|小さな円（色分け：カテゴリごと）|
|接続（JOIN）|実線エッジ|
|意味カテゴリ|カラムに色付け（例：id=青, time=緑, price=赤）|

### その他：

- 不明な型・構造は空欄またはグレー表示
- 構造はあくまで**「クエリで出現した範囲のみ」**

---
### 擬似コード
def visualize_schema(schema, semantic_labels):
    1. NetworkXグラフGを初期化
    2. 各テーブルごとに以下を行う:
        a. テーブルノードを追加（属性: type='table'）
        b. カラムごとに以下を行う:
            - ノードID = f"{table}.{column}"
            - semantic_label = semantic_labels.get(ID, "?")
            - カラムノードを追加（属性: type='column', category=semantic_label）
            - エッジを追加: テーブルノード ↔ カラムノード

    3. スキーマ内のJOIN関係をすべて走査して以下を行う:
        - ノードa, b = join key（users.user_id, orders.user_idなど）
        - Gにエッジ a ↔ b を追加（属性: type='join', count=n）

    4. ノード属性を用いて色・形状をマッピング:
        - type='table' → 円形、大サイズ
        - type='column' → 小サイズ、カテゴリ別色分け（例: id=青, time=緑）

    5. matplotlibでNetworkXを描画:
        - layoutは spring_layout / kamada_kawai_layout など
        - 凡例：色→意味ラベル、線種→JOIN or 所属



# ✅ 構造情報の「リレーショナルスキーマ形式」出力仕様（追加機能）

---

構造可視化の出力形式として、  
**E-R図スタイルの可視化（NetworkXなど）**に加えて、  
**リレーショナルスキーマの表形式（テーブル定義風）**での出力にも対応する。

---

## 📌 出力フォーマット案

plaintext
コードをコピーする
`Table: users   - user_id (id)        [confirmed]   - name (name)         [confirmed]  Table: orders   - order_id (id)       [confirmed]   - user_id (id)        [confirmed] → users.user_id  Table: logs   - user_id (id)        [inferred]  ≈ users.user_id (score: 0.89)   - timestamp (time)    [confirmed]`

- `()` 内は **意味カテゴリ**（NLP/Column2Vecによるラベル）
- `[]` 内は **出所フラグ**：`confirmed` / `inferred`
- `→` や `≈` で **接続先のテーブル・カラム or 類似カラム** を示す

---

## 🧩 実装ポイント

### 🔹 出力先

- `output/schema_structured_###.txt` などに保存
- または `print_structured_schema(schema)` のような関数でターミナル出力

### 🔹 使用情報ソース

- `schema_store.schema` の confirmed 構造（テーブル・カラム・JOIN）
- `column2vec_trainer` の出力（類似カラム・スコア）
- `nlp_analyzer` の出力（カラムごとの意味ラベル）

---

## 🛠 スケルトン関数案（`visualizer.py` or `schema_formatter.py`）

python

コードをコピーする

`def print_structured_schema(schema_dict, semantic_labels={}, similarity_links={}):     """     スキーマをリレーショナル形式で出力する     - schema_dict: schema_store.schema の dict構造     - semantic_labels: {'users.user_id': 'id', ...}     - similarity_links: {('logs.user_id', 'users.user_id'): 0.89}     """     for table, info in schema_dict['tables'].items():         print(f"\nTable: {table}")         for col in sorted(info['columns']):             full_col = f"{table}.{col}"             category = semantic_labels.get(full_col, '?')             source = 'confirmed'             line = f"  - {col} ({category}) [{source}]"              # 類似カラムの表示             for (a, b), score in similarity_links.items():                 if a == full_col:                     line += f"  ≈ {b} (score: {score:.2f})"                 elif b == full_col:                     line += f"  ≈ {a} (score: {score:.2f})"              print(line)`

---

## ✅ 使い分けまとめ

|表示形式|用途|実装モジュール|
|---|---|---|
|グラフ（可視化）|全体構造の直感的理解、探索補助|`visualizer.py`|
|スキーマ表形式|設計書風の記述、文書化、比較、出力用|`schema_formatter.py`（または統合）|

---

## ✅ 出力ファイル構成（例）

pgsql

コードをコピーする

`output/ ├── schema_snapshot_003.json         ← 生データ ├── query_log_003.json               ← 差分ログ ├── schema_structured_003.txt        ← リレーショナル表示 ├── schema_graph_003.png             ← グラフ可視化`

---
### 擬似コード　第一段階
def draw_er_diagram(schema, semantic_labels={}):
    1. matplotlibの描画領域を初期化
    2. 各テーブルを走査して以下を実行:
        a. エンティティ（四角）を描画
        b. テーブル内にカラムをリストアップ
            - semantic_labels から属性ラベルも添える
            - 主キー候補は下線 or 太字表示（名前に 'id' を含むなどの仮判定）

    3. connections（JOIN情報）を走査:
        - JOINされている2つのカラムの親テーブルを特定
        - 親テーブルA → 子テーブルB へ線を引く（矢印付き）
        - 多対一などの注釈は count ベースでオプション表示

    4. 凡例・タイトル・レイアウト調整
    5. PNGファイルまたは描画出力

## ✅ 次のステップ

- 上記関数 `print_structured_schema` の実装・出力を実行してみる
- `column2vec_trainer` に `similarity_links` を吐かせて組み合わせる
- 将来的には **ER図 ↔ リレーショナルスキーマ の相互変換**にも拡張可